"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const DEFAULT_GOOGLE_API_URL = 'https://places.googleapis.com/v1/places:autocomplete';
const GooglePlacesTextInput = /*#__PURE__*/(0, _react.forwardRef)(({
  apiKey,
  value,
  placeHolderText,
  proxyUrl,
  languageCode,
  includedRegionCodes,
  types = [],
  biasPrefixText,
  minCharsToFetch = 1,
  onPlaceSelect,
  onTextChange,
  debounceDelay = 200,
  showLoadingIndicator = true,
  showClearButton = true,
  forceRTL = undefined,
  style = {},
  hideOnKeyboardDismiss = false
}, ref) => {
  const [predictions, setPredictions] = (0, _react.useState)([]);
  const [loading, setLoading] = (0, _react.useState)(false);
  const [inputText, setInputText] = (0, _react.useState)(value || '');
  const [showSuggestions, setShowSuggestions] = (0, _react.useState)(false);
  const debounceTimeout = (0, _react.useRef)(null);
  const inputRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    return () => {
      if (debounceTimeout.current) {
        clearTimeout(debounceTimeout.current);
      }
    };
  }, []);

  // Add keyboard listener
  (0, _react.useEffect)(() => {
    if (hideOnKeyboardDismiss) {
      const keyboardDidHideSubscription = _reactNative.Keyboard.addListener('keyboardDidHide', () => setShowSuggestions(false));
      return () => {
        keyboardDidHideSubscription.remove();
      };
    }
    // Return empty cleanup function if not using the listener
    return () => {};
  }, [hideOnKeyboardDismiss]);

  // Expose methods to parent through ref
  (0, _react.useImperativeHandle)(ref, () => ({
    clear: () => {
      setInputText('');
      setPredictions([]);
      setShowSuggestions(false);
    },
    focus: () => {
      inputRef.current?.focus();
    }
  }));
  const fetchPredictions = async text => {
    if (!text || text.length < minCharsToFetch) {
      setPredictions([]);
      return;
    }
    const processedText = biasPrefixText ? biasPrefixText(text) : text;
    try {
      setLoading(true);
      const API_URL = proxyUrl ? proxyUrl : DEFAULT_GOOGLE_API_URL;
      const headers = {
        'Content-Type': 'application/json'
      };
      if (apiKey || apiKey !== '') {
        headers['X-Goog-Api-Key'] = apiKey;
      }
      const response = await fetch(API_URL, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          input: processedText,
          languageCode,
          ...(includedRegionCodes?.length > 0 && {
            includedRegionCodes
          }),
          ...(types.length > 0 && {
            includedPrimaryTypes: types
          })
        })
      });
      const data = await response.json();
      if (data.suggestions) {
        setPredictions(data.suggestions);
        setShowSuggestions(true);
      } else {
        setPredictions([]);
      }
    } catch (error) {
      console.error('Error fetching predictions:', error);
      setPredictions([]);
    } finally {
      setLoading(false);
    }
  };
  const handleTextChange = text => {
    setInputText(text);
    onPlaceSelect(null);
    onTextChange?.(text);
    if (debounceTimeout.current) {
      clearTimeout(debounceTimeout.current);
    }
    debounceTimeout.current = setTimeout(() => {
      fetchPredictions(text);
    }, debounceDelay);
  };
  const handleSuggestionPress = suggestion => {
    const place = suggestion.placePrediction;
    setInputText(place.structuredFormat.mainText.text);
    setShowSuggestions(false);
    _reactNative.Keyboard.dismiss();
    onPlaceSelect(place); // Notify parent with selected place
  };

  // Show suggestions on focus if text length > minCharsToFetch
  const handleFocus = () => {
    if (inputText.length >= minCharsToFetch) {
      fetchPredictions(inputText);
      setShowSuggestions(true);
    }
  };

  // RTL detection logic
  const isRTL = forceRTL !== undefined ? forceRTL : isRTLText(placeHolderText);
  const renderSuggestion = ({
    item
  }) => {
    const {
      mainText,
      secondaryText
    } = item.placePrediction.structuredFormat;
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.TouchableOpacity, {
      style: [styles.suggestionItem,
      // Inherit background color from container if not specified
      {
        backgroundColor: style.suggestionsContainer?.backgroundColor || '#efeff1'
      }, style.suggestionItem],
      onPress: () => handleSuggestionPress(item),
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Text, {
        style: [styles.mainText, style.suggestionText?.main, getTextAlign()],
        children: mainText.text
      }), secondaryText && /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Text, {
        style: [styles.secondaryText, style.suggestionText?.secondary, getTextAlign()],
        children: secondaryText.text
      })]
    });
  };
  const renderSuggestions = () => {
    if (!showSuggestions || predictions.length === 0) return null;
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
      style: [styles.suggestionsContainer, style.suggestionsContainer],
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.FlatList, {
        data: predictions,
        renderItem: renderSuggestion,
        keyExtractor: item => item.placePrediction.placeId,
        keyboardShouldPersistTaps: "always",
        style: style.suggestionsList,
        scrollEnabled: true,
        bounces: false,
        nestedScrollEnabled: true
      })
    });
  };
  const getPadding = () => {
    const physicalRTL = _reactNative.I18nManager.isRTL;
    const clearButtonPadding = showClearButton ? 75 : 45;
    if (isRTL !== physicalRTL) {
      return {
        paddingStart: clearButtonPadding,
        paddingEnd: 15
      };
    }
    return {
      paddingStart: 15,
      paddingEnd: clearButtonPadding
    };
  };
  const getTextAlign = () => {
    const isDeviceRTL = _reactNative.I18nManager.isRTL;
    if (isDeviceRTL) {
      // Device is RTL, so "left" and "right" are swapped
      return {
        textAlign: isRTL ? 'left' : 'right'
      };
    } else {
      // Device is LTR, normal behavior
      return {
        textAlign: isRTL ? 'right' : 'left'
      };
    }
  };
  const getIconPosition = paddingValue => {
    const physicalRTL = _reactNative.I18nManager.isRTL;
    if (isRTL !== physicalRTL) {
      return {
        start: paddingValue
      };
    }
    return {
      end: paddingValue
    };
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
    style: [styles.container, style.container],
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.TextInput, {
        ref: inputRef,
        style: [styles.input, style.input, getPadding(), {
          textAlign: isRTL ? 'right' : 'left'
        }],
        placeholder: placeHolderText,
        placeholderTextColor: style.placeholder?.color || '#666666',
        value: inputText,
        onChangeText: handleTextChange,
        onFocus: handleFocus,
        onBlur: () => setShowSuggestions(false),
        clearButtonMode: "never" // Disable iOS native clear button
      }), showClearButton && inputText !== '' && /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.TouchableOpacity, {
        style: [styles.clearButton, getIconPosition(12)],
        onPress: () => {
          setInputText('');
          setPredictions([]);
          setShowSuggestions(false);
          onPlaceSelect?.(null);
          onTextChange?.('');
          inputRef.current?.focus();
        },
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Text, {
          style: _reactNative.Platform.select({
            ios: styles.iOSclearButton,
            android: styles.androidClearButton
          }),
          children: 'Ã—'
        })
      }), loading && showLoadingIndicator && /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.ActivityIndicator, {
        style: [styles.loadingIndicator, getIconPosition(45)],
        size: 'small',
        color: style.loadingIndicator?.color || '#000000'
      })]
    }), renderSuggestions()]
  });
});
const styles = _reactNative.StyleSheet.create({
  container: {},
  input: {
    height: 50,
    borderRadius: 6,
    borderWidth: 1,
    paddingHorizontal: 10,
    backgroundColor: 'white',
    fontSize: 16
  },
  suggestionsContainer: {
    backgroundColor: '#efeff1',
    // default background
    borderRadius: 6,
    marginTop: 3,
    overflow: 'hidden',
    maxHeight: 200
  },
  suggestionItem: {
    padding: 10,
    borderBottomWidth: _reactNative.StyleSheet.hairlineWidth,
    borderBottomColor: '#c8c7cc'
  },
  mainText: {
    fontSize: 16,
    textAlign: 'left',
    color: '#000000'
  },
  secondaryText: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
    textAlign: 'left'
  },
  clearButton: {
    position: 'absolute',
    top: '50%',
    transform: [{
      translateY: -13
    }],
    padding: 0
  },
  loadingIndicator: {
    position: 'absolute',
    top: '50%',
    transform: [{
      translateY: -10
    }]
  },
  iOSclearButton: {
    fontSize: 18,
    fontWeight: '400',
    color: 'white',
    backgroundColor: '#999',
    width: 25,
    height: 25,
    borderRadius: 12.5,
    textAlign: 'center',
    textAlignVertical: 'center',
    lineHeight: 19,
    includeFontPadding: false
  },
  androidClearButton: {
    fontSize: 24,
    fontWeight: '400',
    color: 'white',
    backgroundColor: '#999',
    width: 24,
    height: 24,
    borderRadius: 12,
    textAlign: 'center',
    textAlignVertical: 'center',
    lineHeight: 20,
    includeFontPadding: false
  }
});
const isRTLText = text => {
  if (!text) return false;
  // Hebrew: \u0590-\u05FF
  // Arabic: \u0600-\u06FF, \u0750-\u077F (Arabic Supplement), \u0870-\u089F (Arabic Extended-B)
  // Arabic Presentation Forms: \uFB50-\uFDFF, \uFE70-\uFEFF
  const rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u0870-\u089F\uFB50-\uFDFF\uFE70-\uFEFF]/;
  return rtlRegex.test(text);
};
var _default = exports.default = GooglePlacesTextInput;
//# sourceMappingURL=GooglePlacesTextInput.js.map